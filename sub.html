<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>家系図プロ - 家系図作成ツール</title>
  
  <!-- Libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3b82f6',
            secondary: '#64748b',
            canvas: '#f8fafc',
          },
          cursor: {
            'grab': 'grab',
            'grabbing': 'grabbing',
          }
        }
      }
    }
  </script>
  <style>
    /* Hide scrollbar for canvas container */
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f8fafc;
    }
  </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.4",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/",
    "react/": "https://esm.sh/react@^19.2.4/",
    "uuid": "https://esm.sh/uuid@^13.0.0"
  }
}
</script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="react">
    const { useState, useEffect, useRef, useMemo, useCallback, memo } = React;

    // --- Constants ---
    // Increased card size for better readability
    const CARD_WIDTH = 280; 
    const CARD_HEIGHT = 170; 
    const STORAGE_KEY = 'family_tree_data';
    
    // Layout Constants (Adjusted for larger cards)
    const LAYER_HEIGHT = 260; 
    const SIBLING_GAP = 50;   
    const COUSIN_GAP = 140;   
    const SPOUSE_GAP = 50;    

    // Initial Data
    const INITIAL_PEOPLE = [
      {
        id: 'p1',
        surname: '佐藤',
        givenName: '一郎',
        maidenName: '',
        birthDate: '1950-05-12',
        gender: 'male',
        parents: [],
        spouses: ['p2'],
        children: ['p3', 'p4'],
        x: 300,
        y: 100,
      },
      {
        id: 'p2',
        surname: '佐藤',
        givenName: '花子',
        maidenName: '田中',
        birthDate: '1952-08-23',
        gender: 'female',
        parents: [],
        spouses: ['p1'],
        children: ['p3', 'p4'],
        x: 650,
        y: 100,
      },
      {
        id: 'p3',
        surname: '佐藤',
        givenName: '健',
        maidenName: '',
        birthDate: '1975-03-15',
        gender: 'male',
        parents: ['p1', 'p2'],
        spouses: ['p5'],
        children: ['p6'],
        x: 200,
        y: 450,
      },
      {
        id: 'p4',
        surname: '鈴木',
        givenName: '優子',
        maidenName: '佐藤',
        birthDate: '1978-11-30',
        gender: 'female',
        parents: ['p1', 'p2'],
        spouses: [],
        children: [],
        x: 600,
        y: 450,
      },
      {
        id: 'p5',
        surname: '佐藤',
        givenName: 'エミ',
        maidenName: '高橋',
        birthDate: '1976-06-10',
        gender: 'female',
        parents: [],
        spouses: ['p3'],
        children: ['p6'],
        x: 0, 
        y: 450,
      },
      {
        id: 'p6',
        surname: '佐藤',
        givenName: '翔太',
        maidenName: '',
        birthDate: '2005-01-20',
        gender: 'male',
        parents: ['p3', 'p5'],
        spouses: [],
        children: [],
        x: 100,
        y: 800,
      },
    ];

    // --- Utils: Date ---
    const calculateAge = (birthDateString) => {
      if (!birthDateString) return null;
      const today = new Date();
      const birthDate = new Date(birthDateString);
      if (isNaN(birthDate.getTime())) return null;
      let age = today.getFullYear() - birthDate.getFullYear();
      const m = today.getMonth() - birthDate.getMonth();
      if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
        age--;
      }
      return age;
    };

    // --- Utils: Geometry ---
    const getCardCenter = (x, y) => ({
      x: x + CARD_WIDTH / 2,
      y: y + CARD_HEIGHT / 2,
    });

    const getCardTop = (x, y) => ({
      x: x + CARD_WIDTH / 2,
      y: y,
    });

    const getCardBottom = (x, y) => ({
      x: x + CARD_WIDTH / 2,
      y: y + CARD_HEIGHT,
    });

    // --- Utils: Relationship ---
    const analyzeRelationships = (subjectId, people) => {
      const map = new Map();
      const personMap = new Map(people.map(p => [p.id, p]));
      const subject = personMap.get(subjectId);

      if (!subject) return map;

      map.set(subject.id, { label: '本人', degree: 0, type: 'self' });

      subject.spouses.forEach(spouseId => {
        map.set(spouseId, { label: '配偶者', degree: 0, type: 'affine' });
      });

      const queue = [];
      const visited = new Set();

      queue.push({ id: subject.id, degree: 0, tags: [] });
      visited.add(subject.id);

      while (queue.length > 0) {
        const item = queue.shift();
        if (!item) continue;
        const { id, degree, tags } = item;

        const current = personMap.get(id);
        if (!current) continue;

        current.parents.forEach(pid => {
          if (!visited.has(pid)) {
            visited.add(pid);
            const newTags = [...tags, 'up'];
            const newDegree = degree + 1;
            
            let label = `${newDegree}親等`;
            if (newTags.join(',') === 'up') label = personMap.get(pid)?.gender === 'female' ? '母' : '父';
            else if (newTags.join(',') === 'up,up') label = personMap.get(pid)?.gender === 'female' ? '祖母' : '祖父';
            else if (newTags.join(',') === 'up,up,up') label = personMap.get(pid)?.gender === 'female' ? '曾祖母' : '曾祖父';

            map.set(pid, { label, degree: newDegree, type: 'blood' });
            queue.push({ id: pid, degree: newDegree, tags: newTags });
          }
        });

        current.children.forEach(cid => {
          if (!visited.has(cid)) {
            visited.add(cid);
            const newTags = [...tags, 'down'];
            const newDegree = degree + 1;

            let label = `${newDegree}親等`;
            
            if (newTags.join(',') === 'down') {
                const child = personMap.get(cid);
                if (child) {
                    if (child.gender === 'male' || child.gender === 'female') {
                        const sameGenderSiblings = current.children
                            .map(id => personMap.get(id))
                            .filter(p => p && p.gender === child.gender);
                        
                        sameGenderSiblings.sort((a, b) => {
                            const dateA = a.birthDate || '9999-99-99';
                            const dateB = b.birthDate || '9999-99-99';
                            if (dateA !== dateB) return dateA.localeCompare(dateB);
                            return a.id.localeCompare(b.id);
                        });

                        const index = sameGenderSiblings.findIndex(p => p.id === cid);
                        const suffix = child.gender === 'male' ? '男' : '女';
                        
                        if (index === 0) label = `長${suffix}`;
                        else if (index === 1) label = `次${suffix}`;
                        else if (index === 2) label = `三${suffix}`;
                        else label = `${index + 1}${suffix}`;
                    } else {
                        label = '子';
                    }
                }
            }
            else if (newTags.join(',') === 'down,down') label = '孫';
            else if (newTags.join(',') === 'down,down,down') label = 'ひ孫';
            else if (newTags.join(',') === 'up,down') {
                const p = personMap.get(cid);
                if (p) {
                    const ageDiff = (p.birthDate && subject.birthDate) ? p.birthDate < subject.birthDate : false;
                    if (p.gender === 'male') label = ageDiff ? '兄' : '弟';
                    else if (p.gender === 'female') label = ageDiff ? '姉' : '妹';
                    else label = '兄弟姉妹';
                }
            }
            else if (newTags.join(',') === 'up,up,down') {
                label = personMap.get(cid)?.gender === 'male' ? 'おじ' : 'おば';
            }
            else if (newTags.join(',') === 'up,down,down') {
                label = personMap.get(cid)?.gender === 'male' ? '甥' : '姪';
            }

            map.set(cid, { label, degree: newDegree, type: 'blood' });
            queue.push({ id: cid, degree: newDegree, tags: newTags });
          }
        });

        current.spouses.forEach(sid => {
            if (!visited.has(sid)) {
                visited.add(sid);
                map.set(sid, { label: '親族(配偶者)', degree: degree, type: 'affine' });
                queue.push({ id: sid, degree: degree, tags: [...tags, 'spouse'] });
            }
        });
      }
      return map;
    };

    // --- Utils: Recursive AutoLayout ---
    const performAutoLayout = (targetPeople) => {
        const people = JSON.parse(JSON.stringify(targetPeople));
        const personMap = new Map(people.map(p => [p.id, p]));
        
        // 1. Calculate Generations
        const generations = new Map();
        people.forEach(p => generations.set(p.id, 0));
        let changed = true;
        let iter = 0;
        while(changed && iter < 50) {
            changed = false;
            people.forEach(p => {
                let maxP = -1;
                p.parents.forEach(pid => {
                    if (generations.has(pid)) maxP = Math.max(maxP, generations.get(pid));
                });
                if (maxP !== -1) {
                    if (generations.get(p.id) !== maxP + 1) {
                        generations.set(p.id, maxP + 1);
                        changed = true;
                    }
                }
            });
            iter++;
        }
        
        // Align spouses to max gen
        for(let i=0; i<3; i++) {
            people.forEach(p => {
                const myGen = generations.get(p.id);
                p.spouses.forEach(sid => {
                    if(generations.has(sid)) {
                        const sGen = generations.get(sid);
                        const maxG = Math.max(myGen, sGen);
                        if(myGen < maxG) generations.set(p.id, maxG);
                        if(sGen < maxG) generations.set(sid, maxG);
                    }
                });
            });
        }

        // 2. Identify Roots (Gen 0)
        // Groups are defined by couples or singles
        const visited = new Set();
        const roots = [];

        // Sort people to handle deterministic ordering
        people.sort((a, b) => a.id.localeCompare(b.id));

        people.forEach(p => {
            if (generations.get(p.id) === 0 && !visited.has(p.id)) {
                // Form a unit (Person + Spouses)
                const unit = [p.id];
                visited.add(p.id);
                p.spouses.forEach(sid => {
                    if (!visited.has(sid) && generations.get(sid) === 0) {
                        unit.push(sid);
                        visited.add(sid);
                    }
                });
                roots.push(unit);
            }
        });

        // 3. Recursive Size Calculation & Placement
        // Returns the bounding width of the subtree
        const getUnitWidth = (unitIds) => {
            // My Width (Cards + Spouses)
            const myWidth = unitIds.length * CARD_WIDTH + (unitIds.length - 1) * SPOUSE_GAP;

            // Children Width
            // Collect all children of this unit
            let childrenIds = [];
            unitIds.forEach(uid => {
                const p = personMap.get(uid);
                if (p) childrenIds.push(...p.children);
            });
            // Unique children
            childrenIds = [...new Set(childrenIds)];
            
            // Filter only children in next generation (avoid loop weirdness)
            const myGen = generations.get(unitIds[0]);
            childrenIds = childrenIds.filter(cid => generations.get(cid) === myGen + 1);

            if (childrenIds.length === 0) {
                return myWidth;
            }

            // Group children by siblings/couples (Recursive steps)
            // But actually, we just need to group children who are married to each other or single
            // And sum their widths.
            // Note: Children might have spouses who are NOT children of this unit.
            
            const childUnits = [];
            const childVisited = new Set();
            
            // Sort children by birthdate or ID
             childrenIds.sort((a, b) => {
                const pa = personMap.get(a);
                const pb = personMap.get(b);
                const da = pa.birthDate || '9999';
                const db = pb.birthDate || '9999';
                return da.localeCompare(db);
            });

            childrenIds.forEach(cid => {
                if (childVisited.has(cid)) return;
                
                // Form child unit (Child + Spouses)
                const cUnit = [cid];
                childVisited.add(cid);
                
                const child = personMap.get(cid);
                child.spouses.forEach(sid => {
                    // Only include spouse if spouse is NOT a sibling (cousin marriage edge case ignored for simplicity here)
                    // and if spouse is in the people list
                    if (personMap.has(sid) && !childVisited.has(sid)) {
                        cUnit.push(sid);
                        childVisited.add(sid);
                    }
                });
                childUnits.push(cUnit);
            });

            let totalChildrenWidth = 0;
            const childWidths = childUnits.map(cu => {
                const w = getUnitWidth(cu); // Recurse
                return w;
            });

            if (childWidths.length > 0) {
                totalChildrenWidth = childWidths.reduce((sum, w) => sum + w, 0) + (childWidths.length - 1) * SIBLING_GAP;
            }

            return Math.max(myWidth, totalChildrenWidth);
        };

        const setPositions = (unitIds, startX, startY, availableWidth) => {
             // My Width
            const unitWidth = unitIds.length * CARD_WIDTH + (unitIds.length - 1) * SPOUSE_GAP;
            
            // Center the parents within the available width
            let currentX = startX + (availableWidth - unitWidth) / 2;

            unitIds.forEach(uid => {
                const p = personMap.get(uid);
                p.x = currentX;
                p.y = startY;
                currentX += CARD_WIDTH + SPOUSE_GAP;
            });

            // Position Children
            let childrenIds = [];
            unitIds.forEach(uid => {
                const p = personMap.get(uid);
                if (p) childrenIds.push(...p.children);
            });
            childrenIds = [...new Set(childrenIds)];
            const myGen = generations.get(unitIds[0]);
            childrenIds = childrenIds.filter(cid => generations.get(cid) === myGen + 1);

            if (childrenIds.length > 0) {
                const childUnits = [];
                const childVisited = new Set();

                // Same sort as above
                childrenIds.sort((a, b) => {
                    const pa = personMap.get(a);
                    const pb = personMap.get(b);
                    const da = pa.birthDate || '9999';
                    const db = pb.birthDate || '9999';
                    return da.localeCompare(db);
                });

                childrenIds.forEach(cid => {
                    if (childVisited.has(cid)) return;
                    const cUnit = [cid];
                    childVisited.add(cid);
                    const child = personMap.get(cid);
                    child.spouses.forEach(sid => {
                         if (personMap.has(sid) && !childVisited.has(sid)) {
                            cUnit.push(sid);
                            childVisited.add(sid);
                        }
                    });
                    childUnits.push(cUnit);
                });

                // Calculate widths to distribute
                const widths = childUnits.map(u => getUnitWidth(u));
                const totalCWidth = widths.reduce((a,b)=>a+b,0) + (widths.length-1)*SIBLING_GAP;
                
                // Center the children block under the parents
                let childStartX = startX + (availableWidth - totalCWidth) / 2;
                
                childUnits.forEach((cu, idx) => {
                    setPositions(cu, childStartX, startY + LAYER_HEIGHT, widths[idx]);
                    childStartX += widths[idx] + SIBLING_GAP;
                });
            }
        };

        // Execution
        let currentRootX = 0;
        roots.forEach(rootUnit => {
            const width = getUnitWidth(rootUnit);
            setPositions(rootUnit, currentRootX, 100, width);
            currentRootX += width + COUSIN_GAP; // Large gap between separate trees
        });

        // Center entire tree
        const finalMinX = Math.min(...people.map(p => p.x));
        const finalMaxX = Math.max(...people.map(p => p.x));
        const offset = -(finalMinX + finalMaxX) / 2 + (window.innerWidth/2) - (CARD_WIDTH/2);
        
        return people;
    };

    // --- Helper ---
    const generateId = () => Math.random().toString(36).substr(2, 9);

    // --- Component: NodeCard ---
    const NodeCard = memo(({ person, isSelected, isHidden, relationship, viewSettings, onMouseDown, onClick, onEdit }) => {
      if (isHidden) return null;

      const handleMouseDown = (e) => {
        e.stopPropagation();
        onMouseDown(e, person.id);
      };

      const handleClick = (e) => {
        e.stopPropagation();
        onClick(person.id);
      };

      const handleEditClick = (e) => {
        e.stopPropagation();
        onEdit(person.id);
      };

      let bgClass = 'bg-white';
      let borderColor = 'border-gray-300';

      if (viewSettings.useGenderColor) {
        if (person.gender === 'male') { bgClass = 'bg-blue-50'; borderColor = 'border-blue-200'; }
        else if (person.gender === 'female') { bgClass = 'bg-pink-50'; borderColor = 'border-pink-200'; }
      }

      let ringClass = '';
      if (isSelected) {
          // Changed to RED
          borderColor = 'border-red-500';
          ringClass = 'ring-4 ring-red-100';
      } else if (relationship) {
          if (!viewSettings.useGenderColor) borderColor = 'border-indigo-300';
      }
      
      const iconColor = person.gender === 'male' ? 'text-blue-500' : person.gender === 'female' ? 'text-pink-500' : 'text-purple-500';
      const genderLabel = person.gender === 'male' ? '男性' : person.gender === 'female' ? '女性' : 'その他';

      let badge = null;
      if (relationship) {
          let badgeColor = 'bg-gray-100 text-gray-600';
          if (relationship.type === 'self') badgeColor = 'bg-green-100 text-green-700 border-green-200';
          else if (relationship.label === '配偶者') badgeColor = 'bg-pink-100 text-pink-700 border-pink-200';
          else if (relationship.degree === 1) badgeColor = 'bg-blue-50 text-blue-700 border-blue-100';
          
          badge = (
              <div className={`absolute -top-3.5 left-1/2 -translate-x-1/2 px-3 py-1 rounded-full text-sm font-bold border shadow-sm whitespace-nowrap z-20 ${badgeColor}`}>
                  {relationship.label}
                  {relationship.degree !== 0 && relationship.degree !== null && <span className="ml-1 text-xs opacity-75">({relationship.degree}親等)</span>}
              </div>
          );
      }

      // Display Name Logic
      let displayName = '';
      if (person.displayMaidenName && person.maidenName) {
          // Combine maiden surname with given name
          displayName = `${person.maidenName} ${person.givenName || ''}`.trim();
      } else {
          // Standard: Surname + GivenName
          displayName = person.surname && person.givenName 
              ? `${person.surname} ${person.givenName}` 
              : (person.name || '名称未設定');
      }

      const age = calculateAge(person.birthDate);

      return (
        <div
          style={{
            width: CARD_WIDTH,
            height: CARD_HEIGHT,
            transform: `translate(${person.x}px, ${person.y}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            willChange: 'transform', 
          }}
          className={`${bgClass} rounded-xl shadow-md border-2 ${borderColor} ${ringClass} hover:shadow-lg transition-all cursor-grab active:cursor-grabbing select-none flex flex-col justify-center px-5 z-10 group relative`}
          onMouseDown={handleMouseDown}
          onClick={handleClick}
        >
          {badge}

          <div className="flex items-center gap-4 pr-2">
            <div className={`w-16 h-16 rounded-full bg-white/60 flex items-center justify-center ${iconColor} font-bold text-3xl shrink-0 border border-gray-100 shadow-sm`}>
              {person.givenName ? person.givenName.charAt(0) : '?'}
            </div>
            <div className="overflow-hidden min-w-0">
              <h3 className="font-bold text-gray-800 truncate text-2xl leading-tight pb-1" title={displayName}>
                {displayName}
              </h3>
              <div className="text-base text-gray-600 mt-0.5 leading-snug truncate">
                <span>{person.birthDate || '日付なし'}</span>
                {age !== null && <span className="font-semibold text-gray-700 ml-2">({age}歳)</span>}
              </div>
              <div className="flex gap-1 mt-2">
                 <span className={`text-xs px-2 py-0.5 rounded-full bg-white/60 text-gray-600 uppercase tracking-wider font-medium border border-gray-100`}>
                   {genderLabel}
                 </span>
                 {person.displayMaidenName && person.maidenName && (
                    <span className="text-xs px-2 py-0.5 rounded-full bg-indigo-50 text-indigo-600 border border-indigo-100 font-medium">旧姓</span>
                 )}
              </div>
            </div>
          </div>

          <button
            onClick={handleEditClick}
            className={`absolute top-2 right-2 p-1.5 rounded-full hover:bg-gray-100 text-gray-400 hover:text-blue-600 transition-colors opacity-0 group-hover:opacity-100`}
            title="編集"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
            </svg>
          </button>
          
          <div className="absolute -top-1 left-1/2 w-2 h-2 bg-gray-400 rounded-full -translate-x-1/2 ring-2 ring-white" />
          <div className="absolute -bottom-1 left-1/2 w-2 h-2 bg-gray-400 rounded-full -translate-x-1/2 ring-2 ring-white" />
        </div>
      );
    });

    const EditModal = ({ person, isOpen, onClose, onSave, onDelete, onAddRelative }) => {
      const [formData, setFormData] = useState({});
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
      const [hasMaidenName, setHasMaidenName] = useState(false);

      useEffect(() => {
        if (person) {
          setFormData({
            surname: person.surname || '',
            givenName: person.givenName || '',
            maidenName: person.maidenName || '',
            birthDate: person.birthDate,
            gender: person.gender,
          });
          setHasMaidenName(!!person.maidenName);
        }
        setShowDeleteConfirm(false);
      }, [person, isOpen]);

      if (!isOpen || !person) return null;

      const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
      };

      const handleSave = (e) => {
        e.preventDefault();
        onSave(person.id, formData);
        onClose();
      };

      const handleDeleteClick = () => setShowDeleteConfirm(true);
      const handleConfirmDelete = () => { onDelete(person.id); onClose(); };
      const handleCancelDelete = () => setShowDeleteConfirm(false);

      const displayName = formData.surname ? `${formData.surname} ${formData.givenName}` : 'この人物';

      return (
        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-[100] p-4">
          {showDeleteConfirm ? (
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm overflow-hidden p-6 text-center animate-in fade-in zoom-in duration-200">
               <div className="w-12 h-12 rounded-full bg-red-100 text-red-600 flex items-center justify-center mx-auto mb-4">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                  </svg>
               </div>
               <h3 className="text-lg font-bold text-gray-900 mb-2">削除の確認</h3>
               <p className="text-gray-600 mb-6 text-sm">
                 「{displayName}」を削除しますか？<br/>
                 この人物との関係線もすべて削除されます。<br/>
                 この操作は取り消せません。
               </p>
               <div className="flex gap-3 justify-center">
                 <button onClick={handleCancelDelete} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition">キャンセル</button>
                 <button onClick={handleConfirmDelete} className="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-lg hover:bg-red-700 shadow-sm transition">削除する</button>
               </div>
            </div>
          ) : (
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md overflow-hidden flex flex-col max-h-[90vh]">
              <div className="bg-gray-50 p-4 border-b flex justify-between items-center">
                <h2 className="text-xl font-bold text-gray-800">人物の編集</h2>
                <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              </div>

              <div className="p-6 overflow-y-auto">
                <form id="edit-form" onSubmit={handleSave} className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">苗字</label>
                        <input type="text" name="surname" value={formData.surname || ''} onChange={handleChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition" placeholder="例: 佐藤" autoFocus />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">名前</label>
                        <input type="text" name="givenName" value={formData.givenName || ''} onChange={handleChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition" placeholder="例: 太郎" />
                    </div>
                  </div>

                  <div className="flex items-center gap-2">
                    <input 
                        type="checkbox" 
                        id="hasMaidenName" 
                        checked={hasMaidenName} 
                        onChange={(e) => {
                            setHasMaidenName(e.target.checked);
                            if (!e.target.checked) setFormData(prev => ({...prev, maidenName: ''}));
                        }}
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    />
                    <label htmlFor="hasMaidenName" className="text-sm text-gray-700 select-none cursor-pointer">旧姓を追加する</label>
                  </div>

                  {hasMaidenName && (
                      <div className="animate-in fade-in slide-in-from-top-2 duration-200">
                          <label className="block text-sm font-medium text-gray-700 mb-1">旧姓 (苗字のみ)</label>
                          <input type="text" name="maidenName" value={formData.maidenName || ''} onChange={handleChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition bg-gray-50" placeholder="例: 田中" />
                      </div>
                  )}
                  
                  <div className="grid grid-cols-2 gap-4 pt-2">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">生年月日</label>
                      <input type="date" name="birthDate" value={formData.birthDate || ''} onChange={handleChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">性別</label>
                      <select name="gender" value={formData.gender || 'other'} onChange={handleChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none bg-white">
                        <option value="male">男性</option>
                        <option value="female">女性</option>
                        <option value="other">その他</option>
                      </select>
                    </div>
                  </div>
                </form>

                <div className="mt-8">
                  <h3 className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">関係を追加</h3>
                  <div className="grid grid-cols-3 gap-2">
                    <button type="button" onClick={() => { onAddRelative(person.id, 'parent'); onClose(); }} className="flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg hover:bg-blue-50 hover:border-blue-200 transition group">
                      <div className="w-8 h-8 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center mb-1 group-hover:bg-blue-200">↑</div>
                      <span className="text-xs font-medium text-gray-600">親</span>
                    </button>
                    <button type="button" onClick={() => { onAddRelative(person.id, 'spouse'); onClose(); }} className="flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg hover:bg-pink-50 hover:border-pink-200 transition group">
                       <div className="w-8 h-8 rounded-full bg-pink-100 text-pink-600 flex items-center justify-center mb-1 group-hover:bg-pink-200">♥</div>
                      <span className="text-xs font-medium text-gray-600">配偶者</span>
                    </button>
                    <button type="button" onClick={() => { onAddRelative(person.id, 'child'); onClose(); }} className="flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg hover:bg-green-50 hover:border-green-200 transition group">
                       <div className="w-8 h-8 rounded-full bg-green-100 text-green-600 flex items-center justify-center mb-1 group-hover:bg-green-200">↓</div>
                      <span className="text-xs font-medium text-gray-600">子</span>
                    </button>
                  </div>
                </div>
              </div>

              <div className="bg-gray-50 p-4 border-t flex justify-between items-center">
                <button type="button" onClick={handleDeleteClick} className="text-red-600 hover:text-red-700 text-sm font-medium px-3 py-2 rounded hover:bg-red-50 transition">削除</button>
                <div className="flex gap-3">
                   <button type="button" onClick={onClose} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition">キャンセル</button>
                  <button type="submit" form="edit-form" className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 shadow-sm transition">保存</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    const SettingsModal = ({ isOpen, onClose, currentData, onImport, onReset }) => {
      const [jsonString, setJsonString] = useState('');
      const [error, setError] = useState(null);
      const [successMsg, setSuccessMsg] = useState(null);

      useEffect(() => {
        if (isOpen) {
          setJsonString(JSON.stringify(currentData, null, 2));
          setError(null);
          setSuccessMsg(null);
        }
      }, [isOpen, currentData]);

      if (!isOpen) return null;

      const handleCopy = async () => {
        try {
          await navigator.clipboard.writeText(jsonString);
          setSuccessMsg('クリップボードにコピーしました');
          setTimeout(() => setSuccessMsg(null), 3000);
        } catch (err) {
          setError('コピーに失敗しました');
        }
      };

      const handleReset = () => {
        if (window.confirm('本当に初期データに戻しますか？\n現在の変更内容はすべて失われます。')) {
          onReset();
          onClose();
        }
      };

      const handleImport = () => {
        try {
          if (!jsonString.trim()) {
            setError('データが空です');
            return;
          }
          const parsed = JSON.parse(jsonString);
          if (!Array.isArray(parsed)) throw new Error('データ形式が不正です（配列ではありません）');
          if (parsed.length > 0) {
            const item = parsed[0];
            if (!item.id || !Array.isArray(item.parents)) throw new Error('データ形式が不正です（必要なフィールドが不足しています）');
          }
          onImport(parsed);
          onClose();
        } catch (err) {
          setError('読み込みエラー: ' + (err.message || 'JSON形式を確認してください'));
        }
      };

      return (
        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg flex flex-col max-h-[90vh]">
            <div className="bg-gray-50 p-4 border-b flex justify-between items-center rounded-t-xl">
              <h2 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
                データ管理
              </h2>
              <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
              </button>
            </div>
            <div className="p-6 flex-1 overflow-y-auto">
              <p className="text-sm text-gray-600 mb-4">以下のテキストコードをコピーして保存（バックアップ）するか、保存したコードを貼り付けて「データを読み込む」を押して復元してください。</p>
              <div className="relative">
                <textarea className="w-full h-64 p-3 text-xs font-mono border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none resize-none bg-gray-50 text-gray-700" value={jsonString} onChange={(e) => setJsonString(e.target.value)} placeholder='[{"id": "...", "name": "...", ...}]' />
                <button onClick={handleCopy} className="absolute top-2 right-2 px-2 py-1 bg-white border border-gray-300 rounded text-xs hover:bg-gray-50 text-gray-600 shadow-sm">コピー</button>
              </div>
              {error && <div className="mt-3 p-3 bg-red-50 text-red-700 text-sm rounded border border-red-200">{error}</div>}
              {successMsg && <div className="mt-3 p-3 bg-green-50 text-green-700 text-sm rounded border border-green-200">{successMsg}</div>}
            </div>
            <div className="bg-gray-50 p-4 border-t flex justify-between items-center rounded-b-xl">
               <button onClick={handleReset} className="px-4 py-2 text-sm font-medium text-red-600 bg-white border border-red-200 rounded-lg hover:bg-red-50 transition">初期化</button>
               <div className="flex gap-3">
                 <button onClick={onClose} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition">閉じる</button>
                 <button onClick={handleImport} className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 shadow-sm transition">データを読み込む</button>
               </div>
            </div>
          </div>
        </div>
      );
    };

    // --- Main App Component ---
    const App = () => {
      const [people, setPeople] = useState(() => {
        try {
          const savedData = localStorage.getItem(STORAGE_KEY);
          if (savedData) {
            const parsed = JSON.parse(savedData);
            return parsed.map(p => {
                if (!p.surname && p.name) {
                    const parts = p.name.split(/[\s　]+/);
                    return {
                        ...p,
                        surname: parts[0] || '',
                        givenName: parts.slice(1).join(' ') || '',
                        maidenName: p.maidenName || ''
                    };
                }
                return p;
            });
          }
        } catch (e) {
          console.warn('Failed to load from localStorage', e);
        }
        return INITIAL_PEOPLE;
      });

      const [viewSettings, setViewSettings] = useState({
          showMaidenName: false,
          useGenderColor: false
      });
      const [visibleSurnames, setVisibleSurnames] = useState({});
      const [isFilterOpen, setIsFilterOpen] = useState(false);

      // Helper to determine which name to use for filtering/grouping based on settings
      const getFilterName = useCallback((p) => {
          // Check global setting OR individual setting
          const showMaiden = viewSettings.showMaidenName || p.displayMaidenName;
          if (showMaiden && p.maidenName) {
              return p.maidenName.split(/[\s　]+/)[0];
          }
          return p.surname || (p.name ? p.name.split(/[\s　]+/)[0] : '名称未設定');
      }, [viewSettings.showMaidenName]);

      useEffect(() => {
          const names = new Set();
          people.forEach(p => {
              names.add(getFilterName(p));
          });
          const allNames = Array.from(names).sort();
          
          setVisibleSurnames(prev => {
              // Create a FRESH object to ensure stale names (e.g., from before toggling maiden name) are removed
              const next = {};
              allNames.forEach(s => {
                  if (prev[s] !== undefined) {
                      next[s] = prev[s];
                  } else {
                      // Default new names to visible
                      next[s] = true;
                  }
              });
              return next;
          });
      }, [people, getFilterName]);

      useEffect(() => {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(people));
        } catch (e) {
          console.warn('Failed to save to localStorage', e);
        }
      }, [people]);

      const [viewport, setViewport] = useState({ x: 0, y: 0, scale: 1 });
      const [selectedPersonId, setSelectedPersonId] = useState(null);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [isSettingsOpen, setIsSettingsOpen] = useState(false);
      
      const [draggingNodeId, setDraggingNodeId] = useState(null);
      const [isPanning, setIsPanning] = useState(false);
      
      const mousePosRef = useRef({ x: 0, y: 0 });
      const dragStartPosRef = useRef({ x: 0, y: 0 });
      const isDraggingRef = useRef(false);
      const rafIdRef = useRef(null);
      const containerRef = useRef(null);
      const filterRef = useRef(null);

      useEffect(() => {
          const handleClickOutside = (event) => {
              if (filterRef.current && !filterRef.current.contains(event.target) && isFilterOpen) {
                  setIsFilterOpen(false);
              }
          };
          document.addEventListener('mousedown', handleClickOutside);
          return () => document.removeEventListener('mousedown', handleClickOutside);
      }, [isFilterOpen]);

      const checkVisibility = useCallback((p) => {
          const name = getFilterName(p);
          return visibleSurnames[name] !== false;
      }, [visibleSurnames, getFilterName]);

      const relationshipMap = useMemo(() => {
        if (!selectedPersonId) return new Map();
        return analyzeRelationships(selectedPersonId, people);
      }, [selectedPersonId, people]);

      const connections = useMemo(() => {
        const lines = [];
        const personMap = new Map(people.map(p => [p.id, p]));
        
        // 1. Spouses
        people.forEach(person => {
          person.spouses.forEach(spouseId => {
            const spouse = personMap.get(spouseId);
            if (spouse && person.id < spouse.id) {
              const isPVisible = checkVisibility(person);
              const isSVisible = checkVisibility(spouse);
              if (!isPVisible || !isSVisible) return;

              const start = getCardCenter(person.x, person.y);
              const end = getCardCenter(spouse.x, spouse.y);
              
              lines.push(
                <path key={`spouse-${person.id}-${spouse.id}`} d={`M ${start.x} ${start.y} L ${end.x} ${end.y}`} stroke="#333" strokeWidth="2" fill="none" strokeDasharray="5,5" />
              );
              const midX = (start.x + end.x) / 2;
              const midY = (start.y + end.y) / 2;
              lines.push(<circle key={`spouse-joint-${person.id}-${spouse.id}`} cx={midX} cy={midY} r={4} fill="#fff" stroke="#333" strokeWidth="2" />);
            }
          });
        });

        // 2. Parent-Child (Grouped - T-Shape Style)
        const familyMap = new Map();
        people.forEach(child => {
            if (!checkVisibility(child)) return;
            if (child.parents.length === 0) return;
            
            const parentKey = [...child.parents].sort().join('|');
            if (!familyMap.has(parentKey)) {
                familyMap.set(parentKey, { parents: child.parents, children: [] });
            }
            familyMap.get(parentKey).children.push(child);
        });

        familyMap.forEach((family, key) => {
            const parents = family.parents
                .map(pid => personMap.get(pid))
                .filter(p => !!p && checkVisibility(p));

            const children = family.children;

            if (parents.length === 0 || children.length === 0) return;

            // --- Geometry ---
            
            // 1. Determine Start Point (Source)
            let startX, startY;
            
            // If multiple parents, start from the center point (spouse circle)
            if (parents.length >= 2) {
                 const p1 = parents[0];
                 const p2 = parents[1];
                 const c1 = getCardCenter(p1.x, p1.y);
                 const c2 = getCardCenter(p2.x, p2.y);
                 
                 startX = (c1.x + c2.x) / 2;
                 startY = c1.y; 
            } else {
                 // Single parent: Start from bottom center
                 const p = parents[0];
                 const bottom = getCardBottom(p.x, p.y);
                 startX = bottom.x;
                 startY = bottom.y;
            }

            // 2. Child Bounds & Line Y
            let childMinX = Infinity;
            let childMaxX = -Infinity;
            let childTopY = Infinity;

            children.forEach(c => {
                 const top = getCardTop(c.x, c.y);
                 childMinX = Math.min(childMinX, top.x);
                 childMaxX = Math.max(childMaxX, top.x);
                 childTopY = Math.min(childTopY, top.y);
            });
            
            const childLineY = childTopY - 40; 
            
            // 3. Draw Vertical Drop Line
            lines.push(
                <path 
                    key={`fam-drop-${key}`}
                    d={`M ${startX} ${startY} L ${startX} ${childLineY}`}
                    stroke="#333" strokeWidth="2" fill="none"
                />
            );

            // 4. Horizontal Child Bar
            const cBarStart = Math.min(childMinX, startX);
            const cBarEnd = Math.max(childMaxX, startX);
            
            lines.push(
                <path
                    key={`c-bar-${key}`}
                    d={`M ${cBarStart} ${childLineY} L ${cBarEnd} ${childLineY}`}
                    stroke="#333" strokeWidth="2" fill="none"
                />
            );

            // 5. Stems up from Children
            children.forEach(c => {
                const top = getCardTop(c.x, c.y);
                lines.push(
                    <path
                        key={`c-stem-${c.id}`}
                        d={`M ${top.x} ${childLineY} L ${top.x} ${top.y}`}
                        stroke="#333" strokeWidth="2" fill="none"
                    />
                );
            });
        });

        return lines;
      }, [people, checkVisibility]);

      useEffect(() => {
        let lastX = mousePosRef.current.x;
        let lastY = mousePosRef.current.y;

        const loop = () => {
          const currentX = mousePosRef.current.x;
          const currentY = mousePosRef.current.y;
          const dx = currentX - lastX;
          const dy = currentY - lastY;
          
          if (dx !== 0 || dy !== 0) {
            if (draggingNodeId) {
                 setPeople(prev => prev.map(p => {
                     if (p.id === draggingNodeId) {
                         return { ...p, x: p.x + (dx / viewport.scale), y: p.y + (dy / viewport.scale) };
                     }
                     return p;
                 }));
            } else if (isPanning) {
                 setViewport(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
            }
            lastX = currentX;
            lastY = currentY;
          }
          rafIdRef.current = requestAnimationFrame(loop);
        };

        if (draggingNodeId || isPanning) {
            lastX = mousePosRef.current.x;
            lastY = mousePosRef.current.y;
            loop();
        }
        return () => { if (rafIdRef.current) cancelAnimationFrame(rafIdRef.current); };
      }, [draggingNodeId, isPanning, viewport.scale]);

      const handleCanvasWheel = useCallback((e) => {
        if (e.ctrlKey || e.metaKey) {
           e.preventDefault(); 
           const zoomSensitivity = 0.001;
           const newScale = Math.min(Math.max(0.1, viewport.scale - e.deltaY * zoomSensitivity), 4);
           setViewport(prev => ({ ...prev, scale: newScale }));
        } else {
            setViewport(prev => ({ ...prev, x: prev.x - e.deltaX, y: prev.y - e.deltaY }));
        }
      }, [viewport]);

      const handleCanvasMouseDown = (e) => {
        if (e.button === 1 || (e.button === 0 && e.altKey)) {
            setIsPanning(true);
            mousePosRef.current = { x: e.clientX, y: e.clientY };
            isDraggingRef.current = false;
            e.preventDefault();
        }
      };

      const handleNodeMouseDown = (e, id) => {
          setDraggingNodeId(id);
          mousePosRef.current = { x: e.clientX, y: e.clientY };
          dragStartPosRef.current = { x: e.clientX, y: e.clientY };
          isDraggingRef.current = false;
      };

      const handleMouseMove = (e) => {
        mousePosRef.current = { x: e.clientX, y: e.clientY };
        if (!isDraggingRef.current && (draggingNodeId || isPanning)) {
            const d = Math.abs(e.clientX - dragStartPosRef.current.x) + Math.abs(e.clientY - dragStartPosRef.current.y);
            if (d > 5) isDraggingRef.current = true;
        }
      };

      const handleMouseUp = () => {
        setIsPanning(false);
        setDraggingNodeId(null);
      };

      const handleNodeClick = (id) => {
          if (!isDraggingRef.current) setSelectedPersonId(prev => prev === id ? null : id);
      };

      const handleEditNode = (id) => {
          setSelectedPersonId(id);
          setIsModalOpen(true);
      };

      // Auto Layout Logic Updated: Only affect visible nodes
      const handleAutoLayout = () => {
        const visiblePeople = people.filter(checkVisibility);
        const layoutedVisiblePeople = performAutoLayout(visiblePeople);
        
        const layoutMap = new Map(layoutedVisiblePeople.map(p => [p.id, {x: p.x, y: p.y}]));
        
        setPeople(prev => prev.map(p => {
            if (layoutMap.has(p.id)) {
                const newPos = layoutMap.get(p.id);
                return { ...p, x: newPos.x, y: newPos.y };
            }
            return p;
        }));

        if (layoutedVisiblePeople.length > 0) {
            const minX = Math.min(...layoutedVisiblePeople.map(p => p.x));
            const maxX = Math.max(...layoutedVisiblePeople.map(p => p.x));
            const centerX = (minX + maxX) / 2 + CARD_WIDTH / 2;
            setViewport({ x: window.innerWidth / 2 - centerX, y: 50, scale: 1 });
        }
      };

      const handleImportData = (newData) => {
          const migrated = newData.map(p => {
              if (!p.surname && p.name) {
                  const parts = p.name.split(/[\s　]+/);
                  return { ...p, surname: parts[0] || '', givenName: parts.slice(1).join(' ') || '', maidenName: p.maidenName || '' };
              }
              return p;
          });
          setPeople(migrated);
          setSelectedPersonId(null);
          if (migrated.length > 0) setViewport({ x: 0, y: 0, scale: 1 });
      };

      const handleResetData = () => {
          setPeople(INITIAL_PEOPLE);
          setViewport({ x: 0, y: 0, scale: 1 });
      };

      const handleSavePerson = (id, updates) => {
          setPeople(prev => prev.map(p => (p.id === id ? { ...p, ...updates } : p)));
      };

      const handleDeletePerson = (id) => {
          setIsModalOpen(false);
          if (selectedPersonId === id) setSelectedPersonId(null);
          setPeople(prev => {
              const remaining = prev.filter(p => p.id !== id);
              return remaining.map(p => ({
                  ...p,
                  parents: p.parents.filter(pid => pid !== id),
                  spouses: p.spouses.filter(pid => pid !== id),
                  children: p.children.filter(pid => pid !== id),
              }));
          });
      };

      const handleAddRelative = (sourceId, type) => {
          const sourcePerson = people.find(p => p.id === sourceId);
          if (!sourcePerson) return;
          const newId = generateId();
          const newPerson = { id: newId, surname: '新規', givenName: '人物', maidenName: '', birthDate: '', gender: 'other', parents: [], spouses: [], children: [], x: sourcePerson.x, y: sourcePerson.y };
          const OFFSET_X = CARD_WIDTH + 50;
          const OFFSET_Y = CARD_HEIGHT + 100;

          if (type === 'spouse') {
              newPerson.x = sourcePerson.x + OFFSET_X;
              newPerson.spouses = [sourceId];
              const childrenIds = sourcePerson.children;
              setPeople(prev => {
                  let nextPeople = prev.map(p => p.id === sourceId ? { ...p, spouses: [...p.spouses, newId] } : p);
                  if (childrenIds.length > 0) {
                      newPerson.children = [...childrenIds];
                      nextPeople = nextPeople.map(p => {
                          if (childrenIds.includes(p.id)) {
                               const currentParents = p.parents || [];
                               if (!currentParents.includes(newId)) return { ...p, parents: [...currentParents, newId] };
                          }
                          return p;
                      });
                  }
                  return [...nextPeople, newPerson];
              });
          } else if (type === 'child') {
              newPerson.surname = sourcePerson.surname || '';
              newPerson.givenName = '子';
              const spouseId = sourcePerson.spouses[0];
              const spouse = spouseId ? people.find(p => p.id === spouseId) : null;
              if (spouse) {
                  newPerson.parents = [sourceId, spouseId];
                  newPerson.x = (sourcePerson.x + spouse.x) / 2;
                  newPerson.y = sourcePerson.y + OFFSET_Y;
                  setPeople(prev => [
                      ...prev.map(p => {
                          if (p.id === sourceId) return { ...p, children: [...p.children, newId] };
                          if (p.id === spouseId) return { ...p, children: [...p.children, newId] };
                          return p;
                      }),
                      newPerson
                  ]);
              } else {
                  newPerson.parents = [sourceId];
                  newPerson.x = sourcePerson.x;
                  newPerson.y = sourcePerson.y + OFFSET_Y;
                  setPeople(prev => [...prev.map(p => p.id === sourceId ? { ...p, children: [...p.children, newId] } : p), newPerson]);
              }
          } else if (type === 'parent') {
              newPerson.surname = sourcePerson.surname || '';
              newPerson.givenName = '親';
              const existingParentId = sourcePerson.parents[0];
              const existingParent = existingParentId ? people.find(p => p.id === existingParentId) : null;
              if (existingParent) {
                  newPerson.children = [sourceId];
                  newPerson.spouses = [existingParentId];
                  newPerson.x = existingParent.x + OFFSET_X;
                  newPerson.y = existingParent.y;
                  setPeople(prev => [
                      ...prev.map(p => {
                          if (p.id === sourceId) return { ...p, parents: [...p.parents, newId] };
                          if (p.id === existingParentId) return { ...p, spouses: [...p.spouses, newId] };
                          return p;
                      }),
                      newPerson
                  ]);
              } else {
                  newPerson.x = sourcePerson.x;
                  newPerson.y = sourcePerson.y - OFFSET_Y;
                  newPerson.children = [sourceId];
                  setPeople(prev => [...prev.map(p => p.id === sourceId ? { ...p, parents: [...p.parents, newId] } : p), newPerson]);
              }
          }
          setTimeout(() => { setSelectedPersonId(newId); setIsModalOpen(true); }, 100);
      };
      
      const handleToggleMaidenName = () => {
          if (selectedPersonId) {
              setPeople(prev => prev.map(p => {
                  if (p.id === selectedPersonId) {
                      return { ...p, displayMaidenName: !p.displayMaidenName };
                  }
                  return p;
              }));
          } else {
              const nextState = !viewSettings.showMaidenName;
              setViewSettings(prev => ({ ...prev, showMaidenName: nextState }));
              setPeople(prev => prev.map(p => ({
                  ...p,
                  displayMaidenName: nextState
              })));
          }
      };

      const selectedPerson = people.find(p => p.id === selectedPersonId) || null;

      return (
        <div className="w-screen h-screen bg-canvas overflow-hidden flex flex-col font-sans text-slate-800">
           {/* Top Left Controls */}
           <div className="absolute top-4 left-4 z-50 flex flex-col gap-2">
            <div className="bg-white/90 backdrop-blur rounded-lg shadow-lg border border-gray-200 p-1 flex gap-1 items-center">
                <button onClick={handleAutoLayout} className="px-3 py-1.5 text-xs font-bold text-gray-700 hover:bg-gray-100 rounded flex items-center gap-1 transition" title="自動配置"><svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16m-7 6h7" /></svg>自動配置</button>
                <div className="w-px h-4 bg-gray-200 mx-1"></div>
                <button onClick={handleToggleMaidenName} className={`px-3 py-1.5 text-xs font-bold rounded flex items-center gap-1 transition ${viewSettings.showMaidenName ? 'bg-indigo-100 text-indigo-700' : 'text-gray-700 hover:bg-gray-100'}`}>旧姓表示</button>
                <button onClick={() => setViewSettings(s => ({...s, useGenderColor: !s.useGenderColor}))} className={`px-3 py-1.5 text-xs font-bold rounded flex items-center gap-1 transition ${viewSettings.useGenderColor ? 'bg-blue-100 text-blue-700' : 'text-gray-700 hover:bg-gray-100'}`}>性別色分</button>
                <div className="w-px h-4 bg-gray-200 mx-1"></div>
                <div className="relative" ref={filterRef}>
                    <button onClick={() => setIsFilterOpen(!isFilterOpen)} className={`px-3 py-1.5 text-xs font-bold rounded flex items-center gap-1 transition ${isFilterOpen ? 'bg-gray-100' : 'text-gray-700 hover:bg-gray-100'}`} title="苗字でフィルター"><svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z" /></svg>絞り込み</button>
                    {isFilterOpen && (
                        <div className="absolute top-full left-0 mt-2 w-48 bg-white rounded-lg shadow-xl border border-gray-200 overflow-hidden z-50 animate-in fade-in zoom-in-95 duration-100">
                             <div className="bg-gray-50 px-3 py-2 text-xs font-bold text-gray-500 uppercase border-b">苗字・旧姓を選択</div>
                             <div className="max-h-60 overflow-y-auto p-1">
                                {Object.keys(visibleSurnames).sort().map(surname => (
                                    <label key={surname} className="flex items-center gap-2 px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer"><input type="checkbox" checked={visibleSurnames[surname] !== false} onChange={(e) => { const checked = e.target.checked; setVisibleSurnames(prev => ({...prev, [surname]: checked})); }} className="rounded text-blue-600 focus:ring-blue-500 h-4 w-4 border-gray-300" /><span className="text-sm text-gray-700 truncate">{surname || '名称未設定'}</span></label>
                                ))}
                             </div>
                             <div className="border-t p-1 flex justify-between bg-gray-50"><button onClick={() => setVisibleSurnames(prev => { const next = {...prev}; Object.keys(next).forEach(k => next[k] = true); return next; })} className="text-xs text-blue-600 hover:underline px-2 py-1">全選択</button><button onClick={() => setVisibleSurnames(prev => { const next = {...prev}; Object.keys(next).forEach(k => next[k] = false); return next; })} className="text-xs text-gray-500 hover:underline px-2 py-1">全解除</button></div>
                        </div>
                    )}
                </div>
            </div>
          </div>

          {/* Top Right Controls */}
          <div className="absolute top-4 right-4 z-50">
               <button 
                  onClick={() => setIsSettingsOpen(true)} 
                  className="p-2 bg-white/90 backdrop-blur border border-gray-200 text-gray-700 rounded-full hover:bg-gray-100 shadow-lg transition-transform active:scale-95 hover:rotate-90 duration-300"
                  title="設定・データ管理"
               >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </svg>
               </button>
          </div>

          <div 
            ref={containerRef}
            className={`flex-1 w-full h-full relative cursor-${isPanning ? 'grabbing' : draggingNodeId ? 'grabbing' : 'default'}`}
            onWheel={handleCanvasWheel}
            onMouseDown={handleCanvasMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          >
            <div style={{ transform: `translate(${viewport.x}px, ${viewport.y}px) scale(${viewport.scale})`, transformOrigin: '0 0', width: '100%', height: '100%', position: 'absolute' }}>
              <svg className="absolute top-0 left-0 w-full h-full overflow-visible pointer-events-none" style={{ zIndex: 0 }}>
                {connections}
              </svg>
              {people.map(person => {
                  const isVisible = checkVisibility(person);
                  return (
                    <NodeCard key={person.id} person={person} isSelected={selectedPersonId === person.id} isHidden={!isVisible} relationship={relationshipMap.get(person.id)} viewSettings={viewSettings} onMouseDown={handleNodeMouseDown} onClick={handleNodeClick} onEdit={handleEditNode} />
                  );
              })}
            </div>
          </div>

          <EditModal isOpen={isModalOpen} person={selectedPerson} onClose={() => setIsModalOpen(false)} onSave={handleSavePerson} onDelete={handleDeletePerson} onAddRelative={handleAddRelative} />
          <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} currentData={people} onImport={handleImportData} onReset={handleResetData} />
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
