<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>家系図プロ - 家系図作成ツール</title>
  
  <!-- Libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3b82f6',
            secondary: '#64748b',
            canvas: '#f8fafc',
          },
          cursor: {
            'grab': 'grab',
            'grabbing': 'grabbing',
          }
        }
      }
    }
  </script>
  <style>
    /* Hide scrollbar for canvas container */
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    body {
      margin: 0;
      overflow: hidden;
      background-color: #f8fafc;
    }
  </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.4",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/",
    "react/": "https://esm.sh/react@^19.2.4/",
    "uuid": "https://esm.sh/uuid@^13.0.0"
  }
}
</script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="react">
    const { useState, useEffect, useRef, useMemo, useCallback, memo } = React;

    // --- Constants ---
    const CARD_WIDTH = 350; 
    const CARD_HEIGHT = 150; 
    const STORAGE_KEY = 'family_tree_data';
    const VIEWPORT_KEY = 'family_tree_viewport';
    
    // Layout Constants
    const LAYER_HEIGHT = 280; 
    const SIBLING_GAP = 50;   
    const COUSIN_GAP = 140;   
    const SPOUSE_GAP = 50;    

    // Initial Data
    const INITIAL_PEOPLE = [
      { id: 'p1', surname: '佐藤', givenName: '一郎', maidenName: '', birthDate: '1950-05-12', gender: 'male', parents: [], spouses: ['p2'], children: ['p3', 'p4'], x: 300, y: 100 },
      { id: 'p2', surname: '佐藤', givenName: '花子', maidenName: '田中', birthDate: '1952-08-23', gender: 'female', parents: [], spouses: ['p1'], children: ['p3', 'p4'], x: 650, y: 100 },
      { id: 'p3', surname: '佐藤', givenName: '健', maidenName: '', birthDate: '1975-03-15', gender: 'male', parents: ['p1', 'p2'], spouses: ['p5'], children: ['p6'], x: 200, y: 450 },
      { id: 'p4', surname: '鈴木', givenName: '優子', maidenName: '佐藤', birthDate: '1978-11-30', gender: 'female', parents: ['p1', 'p2'], spouses: [], children: [], x: 600, y: 450 },
      { id: 'p5', surname: '佐藤', givenName: 'エミ', maidenName: '高橋', birthDate: '1976-06-10', gender: 'female', parents: [], spouses: ['p3'], children: ['p6'], x: 0, y: 450 },
      { id: 'p6', surname: '佐藤', givenName: '翔太', maidenName: '', birthDate: '2005-01-20', gender: 'male', parents: ['p3', 'p5'], spouses: [], children: [], x: 100, y: 800 },
    ];

    // --- Utils: Date ---
    const calculateAge = (birthDateString) => {
      if (!birthDateString) return null;
      const today = new Date();
      const birthDate = new Date(birthDateString);
      if (isNaN(birthDate.getTime())) return null;
      let age = today.getFullYear() - birthDate.getFullYear();
      const m = today.getMonth() - birthDate.getMonth();
      if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
        age--;
      }
      return age;
    };

    // --- Utils: Geometry ---
    const getCardCenter = (x, y) => ({ x: x + CARD_WIDTH / 2, y: y + CARD_HEIGHT / 2 });
    const getCardTop = (x, y) => ({ x: x + CARD_WIDTH / 2, y: y });
    const getCardBottom = (x, y) => ({ x: x + CARD_WIDTH / 2, y: y + CARD_HEIGHT });

    // --- Utils: Relationship ---
    const analyzeRelationships = (subjectId, people) => {
      const map = new Map();
      const personMap = new Map(people.map(p => [p.id, p]));
      const subject = personMap.get(subjectId);

      if (!subject) return map;

      map.set(subject.id, { label: '本人', degree: 0, type: 'self' });

      subject.spouses.forEach(spouseId => {
        map.set(spouseId, { label: '配偶者', degree: 0, type: 'affine' });
      });

      const queue = [];
      const visited = new Set();
      queue.push({ id: subject.id, degree: 0, tags: [] });
      visited.add(subject.id);

      while (queue.length > 0) {
        const item = queue.shift();
        if (!item) continue;
        const { id, degree, tags } = item;
        const current = personMap.get(id);
        if (!current) continue;

        current.parents.forEach(pid => {
          if (!visited.has(pid)) {
            visited.add(pid);
            const newTags = [...tags, 'up'];
            const newDegree = degree + 1;
            let label = `${newDegree}親等`;
            if (newTags.join(',') === 'up') label = personMap.get(pid)?.gender === 'female' ? '母' : '父';
            else if (newTags.join(',') === 'up,up') label = personMap.get(pid)?.gender === 'female' ? '祖母' : '祖父';
            else if (newTags.join(',') === 'up,up,up') label = personMap.get(pid)?.gender === 'female' ? '曾祖母' : '曾祖父';
            map.set(pid, { label, degree: newDegree, type: 'blood' });
            queue.push({ id: pid, degree: newDegree, tags: newTags });
          }
        });

        current.children.forEach(cid => {
          if (!visited.has(cid)) {
            visited.add(cid);
            const newTags = [...tags, 'down'];
            const newDegree = degree + 1;
            let label = `${newDegree}親等`;
            if (newTags.join(',') === 'down') {
                const child = personMap.get(cid);
                if (child) {
                    if (child.gender === 'male' || child.gender === 'female') {
                        const sameGenderSiblings = current.children.map(id => personMap.get(id)).filter(p => p && p.gender === child.gender);
                        sameGenderSiblings.sort((a, b) => {
                            const dateA = a.birthDate || '9999-99-99';
                            const dateB = b.birthDate || '9999-99-99';
                            return dateA.localeCompare(dateB) || a.id.localeCompare(b.id);
                        });
                        const index = sameGenderSiblings.findIndex(p => p.id === cid);
                        const suffix = child.gender === 'male' ? '男' : '女';
                        label = (index === 0 ? '長' : index === 1 ? '次' : index === 2 ? '三' : `${index + 1}`) + suffix;
                    } else label = '子';
                }
            }
            else if (newTags.join(',') === 'down,down') label = '孫';
            else if (newTags.join(',') === 'down,down,down') label = 'ひ孫';
            else if (newTags.join(',') === 'up,down') {
                const p = personMap.get(cid);
                if (p) {
                    const ageDiff = (p.birthDate && subject.birthDate) ? p.birthDate < subject.birthDate : false;
                    label = p.gender === 'male' ? (ageDiff ? '兄' : '弟') : (ageDiff ? '姉' : '妹');
                    if(p.gender === 'other') label = '兄弟姉妹';
                }
            }
            else if (newTags.join(',') === 'up,up,down') label = personMap.get(cid)?.gender === 'male' ? 'おじ' : 'おば';
            else if (newTags.join(',') === 'up,down,down') label = personMap.get(cid)?.gender === 'male' ? '甥' : '姪';

            map.set(cid, { label, degree: newDegree, type: 'blood' });
            queue.push({ id: cid, degree: newDegree, tags: newTags });
          }
        });

        current.spouses.forEach(sid => {
            if (!visited.has(sid)) {
                visited.add(sid);
                map.set(sid, { label: '親族(配偶者)', degree: degree, type: 'affine' });
                queue.push({ id: sid, degree: degree, tags: [...tags, 'spouse'] });
            }
        });
      }
      return map;
    };

    // --- Utils: Recursive AutoLayout (Fixed Centering) ---
    const performAutoLayout = (targetPeople) => {
        const people = JSON.parse(JSON.stringify(targetPeople));
        const personMap = new Map(people.map(p => [p.id, p]));
        
        // 1. Calculate Generations
        const generations = new Map();
        people.forEach(p => generations.set(p.id, 0));
        let changed = true;
        let iter = 0;
        while(changed && iter < 50) {
            changed = false;
            people.forEach(p => {
                let maxP = -1;
                p.parents.forEach(pid => {
                    if (generations.has(pid)) maxP = Math.max(maxP, generations.get(pid));
                });
                if (maxP !== -1) {
                    if (generations.get(p.id) !== maxP + 1) {
                        generations.set(p.id, maxP + 1);
                        changed = true;
                    }
                }
            });
            iter++;
        }
        
        for(let i=0; i<3; i++) {
            people.forEach(p => {
                const myGen = generations.get(p.id);
                p.spouses.forEach(sid => {
                    if(generations.has(sid)) {
                        const sGen = generations.get(sid);
                        const maxG = Math.max(myGen, sGen);
                        if(myGen < maxG) generations.set(p.id, maxG);
                        if(sGen < maxG) generations.set(sid, maxG);
                    }
                });
            });
        }

        // 2. Identify Roots
        const visited = new Set();
        const roots = [];
        people.sort((a, b) => a.id.localeCompare(b.id));

        people.forEach(p => {
            if (generations.get(p.id) === 0 && !visited.has(p.id)) {
                const unit = [p.id];
                visited.add(p.id);
                p.spouses.forEach(sid => {
                    if (!visited.has(sid) && generations.get(sid) === 0) {
                        unit.push(sid);
                        visited.add(sid);
                    }
                });
                unit.sort((a, b) => {
                     const pa = personMap.get(a);
                     const pb = personMap.get(b);
                     if (pa.gender === 'male' && pb.gender !== 'male') return -1;
                     if (pa.gender !== 'male' && pb.gender === 'male') return 1;
                     return a.localeCompare(b);
                });
                roots.push(unit);
            }
        });

        // 2.5 Minimizing crossings (Root mapping)
        const personToRootMap = new Map();
        roots.forEach((rootUnit, index) => {
            const q = [...rootUnit];
            const visitedDesc = new Set(q);
            q.forEach(id => personToRootMap.set(id, index));
            while(q.length > 0){
                const currId = q.shift();
                const p = personMap.get(currId);
                if(p) {
                    p.children.forEach(cid => {
                        if(!visitedDesc.has(cid)){
                            visitedDesc.add(cid);
                            if(!personToRootMap.has(cid)) personToRootMap.set(cid, index);
                            q.push(cid);
                        }
                    });
                }
            }
        });

        const smartSortUnit = (unitIds) => {
             unitIds.sort((a, b) => {
                 const rootA = personToRootMap.has(a) ? personToRootMap.get(a) : 999;
                 const rootB = personToRootMap.has(b) ? personToRootMap.get(b) : 999;
                 if (rootA !== rootB) return rootA - rootB;
                 const pa = personMap.get(a);
                 const pb = personMap.get(b);
                 if (pa.gender === 'male' && pb.gender !== 'male') return -1;
                 if (pa.gender !== 'male' && pb.gender === 'male') return 1;
                 return a.localeCompare(b);
            });
        };

        // 3. Layout Logic
        const getUnitWidth = (unitIds) => {
            const myWidth = unitIds.length * CARD_WIDTH + (unitIds.length - 1) * SPOUSE_GAP;
            let childrenIds = [];
            unitIds.forEach(uid => {
                const p = personMap.get(uid);
                if (p) childrenIds.push(...p.children);
            });
            childrenIds = [...new Set(childrenIds)];
            const myGen = generations.get(unitIds[0]);
            childrenIds = childrenIds.filter(cid => generations.get(cid) === myGen + 1);

            if (childrenIds.length === 0) return myWidth;

            const childUnits = [];
            const childVisited = new Set();
            
            childrenIds.sort((a, b) => {
                const pa = personMap.get(a);
                const pb = personMap.get(b);
                return (pa.birthDate || '9999').localeCompare(pb.birthDate || '9999');
            });

            childrenIds.forEach(cid => {
                if (childVisited.has(cid)) return;
                const cUnit = [cid];
                childVisited.add(cid);
                const child = personMap.get(cid);
                child.spouses.forEach(sid => {
                    if (personMap.has(sid) && !childVisited.has(sid)) {
                        cUnit.push(sid);
                        childVisited.add(sid);
                    }
                });
                smartSortUnit(cUnit);
                childUnits.push(cUnit);
            });

            const childWidths = childUnits.map(cu => getUnitWidth(cu));
            const totalChildrenWidth = childWidths.reduce((sum, w) => sum + w, 0) + (childWidths.length > 0 ? (childWidths.length - 1) * SIBLING_GAP : 0);

            return Math.max(myWidth, totalChildrenWidth);
        };

        const setPositions = (unitIds, startX, startY, availableWidth) => {
            const unitWidth = unitIds.length * CARD_WIDTH + (unitIds.length - 1) * SPOUSE_GAP;
            
            // Gather children
            let childrenIds = [];
            unitIds.forEach(uid => {
                const p = personMap.get(uid);
                if (p) childrenIds.push(...p.children);
            });
            childrenIds = [...new Set(childrenIds)];
            const myGen = generations.get(unitIds[0]);
            childrenIds = childrenIds.filter(cid => generations.get(cid) === myGen + 1);

            let childUnits = [];
            let widths = [];
            let totalCWidth = 0;

            if (childrenIds.length > 0) {
                const childVisited = new Set();
                childrenIds.sort((a, b) => {
                    const pa = personMap.get(a);
                    const pb = personMap.get(b);
                    return (pa.birthDate || '9999').localeCompare(pb.birthDate || '9999');
                });
                childrenIds.forEach(cid => {
                    if (childVisited.has(cid)) return;
                    const cUnit = [cid];
                    childVisited.add(cid);
                    const child = personMap.get(cid);
                    child.spouses.forEach(sid => {
                         if (personMap.has(sid) && !childVisited.has(sid)) {
                            cUnit.push(sid);
                            childVisited.add(sid);
                        }
                    });
                    smartSortUnit(cUnit);
                    childUnits.push(cUnit);
                });
                widths = childUnits.map(u => getUnitWidth(u));
                totalCWidth = widths.reduce((a,b)=>a+b,0) + (widths.length > 0 ? (widths.length-1)*SIBLING_GAP : 0);
            }
            
            // Layout Calculations
            // Center Parents
            const parentX = startX + (availableWidth - unitWidth) / 2;

            // Center Children block
            let childStartX = startX;
            if (totalCWidth > 0) {
                childStartX = startX + (availableWidth - totalCWidth) / 2;
            }

            // Set Parent Coordinates
            let currentX = parentX;
            unitIds.forEach(uid => {
                const p = personMap.get(uid);
                p.x = currentX;
                p.y = startY;
                currentX += CARD_WIDTH + SPOUSE_GAP;
            });

            // Set Child Coordinates (Recursive)
            if (childrenIds.length > 0) {
                let currentCX = childStartX;
                childUnits.forEach((cu, idx) => {
                    setPositions(cu, currentCX, startY + LAYER_HEIGHT, widths[idx]);
                    currentCX += widths[idx] + SIBLING_GAP;
                });
            }
        };

        let currentRootX = 0;
        roots.forEach(rootUnit => {
            const width = getUnitWidth(rootUnit);
            setPositions(rootUnit, currentRootX, 100, width);
            currentRootX += width + COUSIN_GAP;
        });

        return people;
    };

    // --- Helper ---
    const generateId = () => Math.random().toString(36).substr(2, 9);

    // --- Component: NodeCard ---
    const NodeCard = memo(({ person, isSelected, isHidden, relationship, viewSettings, onMouseDown, onClick, onEdit }) => {
      if (isHidden) return null;
      const handleMouseDown = (e) => { e.stopPropagation(); onMouseDown(e, person.id); };
      const handleClick = (e) => { e.stopPropagation(); onClick(person.id); };
      const handleEditClick = (e) => { e.stopPropagation(); onEdit(person.id); };

      let bgClass = 'bg-white', borderColor = 'border-gray-300';
      if (viewSettings.useGenderColor) {
        if (person.gender === 'male') { bgClass = 'bg-blue-50'; borderColor = 'border-blue-200'; }
        else if (person.gender === 'female') { bgClass = 'bg-pink-50'; borderColor = 'border-pink-200'; }
      }
      let ringClass = '';
      if (isSelected) { borderColor = 'border-red-500'; ringClass = 'ring-4 ring-red-100'; }
      else if (relationship && !viewSettings.useGenderColor) borderColor = 'border-indigo-300';
      
      const iconColor = person.gender === 'male' ? 'text-blue-500' : person.gender === 'female' ? 'text-pink-500' : 'text-purple-500';
      const genderLabel = person.gender === 'male' ? '男性' : person.gender === 'female' ? '女性' : 'その他';

      let badge = null;
      if (relationship) {
          let badgeColor = 'bg-gray-100 text-gray-600';
          if (relationship.type === 'self') badgeColor = 'bg-green-100 text-green-700 border-green-200';
          else if (relationship.label === '配偶者') badgeColor = 'bg-pink-100 text-pink-700 border-pink-200';
          else if (relationship.degree === 1) badgeColor = 'bg-blue-50 text-blue-700 border-blue-100';
          
          badge = (
              <div className={`absolute -top-9 left-1/2 -translate-x-1/2 px-5 py-1.5 rounded-full text-xl font-bold border shadow-sm whitespace-nowrap z-20 ${badgeColor}`}>
                  {relationship.label}
                  {relationship.degree !== 0 && relationship.degree !== null && <span className="ml-1 text-base opacity-75">({relationship.degree}親等)</span>}
              </div>
          );
      }

      let displayName = '';
      if (person.displayMaidenName && person.maidenName) displayName = `${person.maidenName} ${person.givenName || ''}`.trim();
      else displayName = person.surname && person.givenName ? `${person.surname} ${person.givenName}` : (person.name || '名称未設定');
      const age = calculateAge(person.birthDate);

      return (
        <div style={{ width: CARD_WIDTH, height: CARD_HEIGHT, transform: `translate(${person.x}px, ${person.y}px)`, position: 'absolute', top: 0, left: 0, willChange: 'transform' }}
          className={`${bgClass} rounded-xl shadow-md border-2 ${borderColor} ${ringClass} hover:shadow-lg transition-all cursor-grab active:cursor-grabbing select-none flex flex-col justify-center px-4 z-10 group relative`}
          onMouseDown={handleMouseDown} onClick={handleClick}>
          {badge}
          <div className="flex items-center gap-4 pr-1">
            <div className={`w-20 h-20 rounded-full bg-white/60 flex items-center justify-center ${iconColor} font-bold text-5xl shrink-0 border border-gray-100 shadow-sm`}>
              {person.givenName ? person.givenName.charAt(0) : '?'}
            </div>
            <div className="overflow-hidden min-w-0">
              <h3 className="font-bold text-gray-800 truncate text-4xl leading-tight pb-1" title={displayName}>{displayName}</h3>
              <div className="text-2xl text-gray-600 mt-1 leading-snug truncate">
                <span>{person.birthDate || '日付なし'}</span>{age !== null && <span className="font-semibold text-gray-700 ml-2">({age}歳)</span>}
              </div>
              <div className="flex gap-2 mt-2">
                 <span className={`text-lg px-3 py-0.5 rounded-full bg-white/60 text-gray-600 uppercase tracking-wider font-medium border border-gray-100`}>{genderLabel}</span>
                 {person.displayMaidenName && person.maidenName && <span className="text-lg px-3 py-0.5 rounded-full bg-indigo-50 text-indigo-600 border border-indigo-100 font-medium">旧姓</span>}
              </div>
            </div>
          </div>
          <button onClick={handleEditClick} className={`absolute top-2 right-2 p-1.5 rounded-full hover:bg-gray-100 text-gray-400 hover:text-blue-600 transition-colors opacity-0 group-hover:opacity-100`} title="編集">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg>
          </button>
        </div>
      );
    });

    // --- Component: EditModal ---
    const EditModal = ({ person, isOpen, onClose, onSave, onDelete, onAddRelative }) => {
      const [view, setView] = useState('main'); // 'main' or 'add'
      const [addType, setAddType] = useState(null); // 'parent', 'spouse', 'child'
      const [formData, setFormData] = useState({});
      const [addFormData, setAddFormData] = useState({});
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
      const [hasMaidenName, setHasMaidenName] = useState(false);

      useEffect(() => {
        if (person && isOpen) {
          setView('main');
          setFormData({
            surname: person.surname || '',
            givenName: person.givenName || '',
            maidenName: person.maidenName || '',
            birthDate: person.birthDate,
            gender: person.gender,
          });
          setHasMaidenName(!!person.maidenName);
        }
        setShowDeleteConfirm(false);
      }, [person, isOpen]);

      if (!isOpen || !person) return null;

      const handleMainChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
      };

      const handleAddChange = (e) => {
          const { name, value } = e.target;
          setAddFormData(prev => ({ ...prev, [name]: value }));
      };

      const handleMainSave = (e) => {
        e.preventDefault();
        onSave(person.id, formData);
        onClose();
      };
      
      const handleAddSave = (e) => {
          e.preventDefault();
          onAddRelative(person.id, addType, addFormData);
          onClose();
      };

      const switchToAdd = (type) => {
          setAddType(type);
          setAddFormData({
              surname: person.surname || '', // Default to same surname
              givenName: '',
              gender: 'other',
              birthDate: ''
          });
          setView('add');
      };

      const displayName = formData.surname ? `${formData.surname} ${formData.givenName}` : 'この人物';
      
      const getAddTitle = () => {
          const name = person.surname && person.givenName ? `${person.surname} ${person.givenName}` : '選択中の人物';
          if (addType === 'parent') return `${name} の親を追加`;
          if (addType === 'child') return `${name} の子を追加`;
          if (addType === 'spouse') return `${name} の配偶者を追加`;
          return '関係者を追加';
      };

      if (view === 'add') {
          return (
             <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-[100] p-4">
                 <div className="bg-white rounded-xl shadow-2xl w-full max-w-md overflow-hidden flex flex-col max-h-[90vh] animate-in slide-in-from-right duration-200">
                    <div className="bg-blue-50 p-4 border-b flex justify-between items-center">
                        <button onClick={() => setView('main')} className="text-blue-600 flex items-center gap-1 hover:underline text-sm font-bold">
                            ← 戻る
                        </button>
                        <h2 className="text-lg font-bold text-blue-900 truncate flex-1 text-center px-2">{getAddTitle()}</h2>
                        <div className="w-10"></div>
                    </div>
                    <div className="p-6 overflow-y-auto">
                        <form id="add-relative-form" onSubmit={handleAddSave} className="space-y-4">
                            <div className="grid grid-cols-2 gap-4">
                                <div><label className="block text-sm font-medium text-gray-700 mb-1">苗字</label><input type="text" name="surname" value={addFormData.surname || ''} onChange={handleAddChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例: 佐藤" autoFocus /></div>
                                <div><label className="block text-sm font-medium text-gray-700 mb-1">名前</label><input type="text" name="givenName" value={addFormData.givenName || ''} onChange={handleAddChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例: 太郎" required /></div>
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <div><label className="block text-sm font-medium text-gray-700 mb-1">生年月日</label><input type="date" name="birthDate" value={addFormData.birthDate || ''} onChange={handleAddChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                                <div><label className="block text-sm font-medium text-gray-700 mb-1">性別</label><select name="gender" value={addFormData.gender || 'other'} onChange={handleAddChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none bg-white"><option value="male">男性</option><option value="female">女性</option><option value="other">その他</option></select></div>
                            </div>
                        </form>
                    </div>
                    <div className="bg-gray-50 p-4 border-t flex justify-end gap-3">
                        <button type="button" onClick={() => setView('main')} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50">キャンセル</button>
                        <button type="submit" form="add-relative-form" className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 shadow-sm">追加する</button>
                    </div>
                 </div>
             </div>
          );
      }

      return (
        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-[100] p-4">
          {showDeleteConfirm ? (
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-sm overflow-hidden p-6 text-center animate-in fade-in zoom-in duration-200">
               <div className="w-12 h-12 rounded-full bg-red-100 text-red-600 flex items-center justify-center mx-auto mb-4">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
               </div>
               <h3 className="text-lg font-bold text-gray-900 mb-2">削除の確認</h3>
               <p className="text-gray-600 mb-6 text-sm">「{displayName}」を削除しますか？<br/>関係線もすべて削除されます。</p>
               <div className="flex gap-3 justify-center">
                 <button onClick={() => setShowDeleteConfirm(false)} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50">キャンセル</button>
                 <button onClick={() => { onDelete(person.id); onClose(); }} className="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-lg hover:bg-red-700 shadow-sm">削除する</button>
               </div>
            </div>
          ) : (
            <div className="bg-white rounded-xl shadow-2xl w-full max-w-md overflow-hidden flex flex-col max-h-[90vh]">
              <div className="bg-gray-50 p-4 border-b flex justify-between items-center">
                <h2 className="text-xl font-bold text-gray-800">人物の編集</h2>
                <button onClick={onClose} className="text-gray-400 hover:text-gray-600"><svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg></button>
              </div>
              <div className="p-6 overflow-y-auto">
                <form id="edit-form" onSubmit={handleMainSave} className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div><label className="block text-sm font-medium text-gray-700 mb-1">苗字</label><input type="text" name="surname" value={formData.surname || ''} onChange={handleMainChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                    <div><label className="block text-sm font-medium text-gray-700 mb-1">名前</label><input type="text" name="givenName" value={formData.givenName || ''} onChange={handleMainChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                  </div>
                  <div className="flex items-center gap-2">
                    <input type="checkbox" id="hasMaidenName" checked={hasMaidenName} onChange={(e) => { setHasMaidenName(e.target.checked); if (!e.target.checked) setFormData(prev => ({...prev, maidenName: ''})); }} className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" />
                    <label htmlFor="hasMaidenName" className="text-sm text-gray-700 select-none cursor-pointer">旧姓を追加する</label>
                  </div>
                  {hasMaidenName && <div><label className="block text-sm font-medium text-gray-700 mb-1">旧姓</label><input type="text" name="maidenName" value={formData.maidenName || ''} onChange={handleMainChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none bg-gray-50" /></div>}
                  <div className="grid grid-cols-2 gap-4 pt-2">
                    <div><label className="block text-sm font-medium text-gray-700 mb-1">生年月日</label><input type="date" name="birthDate" value={formData.birthDate || ''} onChange={handleMainChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none" /></div>
                    <div><label className="block text-sm font-medium text-gray-700 mb-1">性別</label><select name="gender" value={formData.gender || 'other'} onChange={handleMainChange} className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none bg-white"><option value="male">男性</option><option value="female">女性</option><option value="other">その他</option></select></div>
                  </div>
                </form>
                <div className="mt-8">
                  <h3 className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3">関係を追加</h3>
                  <div className="grid grid-cols-3 gap-2">
                    <button type="button" onClick={() => switchToAdd('parent')} className="flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg hover:bg-blue-50 hover:border-blue-200 transition group"><div className="w-8 h-8 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center mb-1 group-hover:bg-blue-200">↑</div><span className="text-xs font-medium text-gray-600">親</span></button>
                    <button type="button" onClick={() => switchToAdd('spouse')} className="flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg hover:bg-pink-50 hover:border-pink-200 transition group"><div className="w-8 h-8 rounded-full bg-pink-100 text-pink-600 flex items-center justify-center mb-1 group-hover:bg-pink-200">♥</div><span className="text-xs font-medium text-gray-600">配偶者</span></button>
                    <button type="button" onClick={() => switchToAdd('child')} className="flex flex-col items-center justify-center p-3 border border-gray-200 rounded-lg hover:bg-green-50 hover:border-green-200 transition group"><div className="w-8 h-8 rounded-full bg-green-100 text-green-600 flex items-center justify-center mb-1 group-hover:bg-green-200">↓</div><span className="text-xs font-medium text-gray-600">子</span></button>
                  </div>
                </div>
              </div>
              <div className="bg-gray-50 p-4 border-t flex justify-between items-center">
                <button type="button" onClick={() => setShowDeleteConfirm(true)} className="text-red-600 hover:text-red-700 text-sm font-medium px-3 py-2 rounded hover:bg-red-50 transition">削除</button>
                <div className="flex gap-3">
                   <button type="button" onClick={onClose} className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50">キャンセル</button>
                  <button type="submit" form="edit-form" className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700 shadow-sm">保存</button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    const SettingsModal = ({ isOpen, onClose, currentData, onImport, onReset }) => {
      const [jsonString, setJsonString] = useState('');
      const [error, setError] = useState(null);
      const [successMsg, setSuccessMsg] = useState(null);
      useEffect(() => { if (isOpen) { setJsonString(JSON.stringify(currentData, null, 2)); setError(null); setSuccessMsg(null); } }, [isOpen, currentData]);
      if (!isOpen) return null;
      const handleCopy = async () => { try { await navigator.clipboard.writeText(jsonString); setSuccessMsg('コピーしました'); } catch { setError('コピー失敗'); } };
      const handleReset = () => { if (window.confirm('初期データに戻しますか？')) { onReset(); onClose(); } };
      const handleImport = () => { try { const parsed = JSON.parse(jsonString); if (!Array.isArray(parsed)) throw new Error('Not array'); onImport(parsed); onClose(); } catch (e) { setError('エラー: ' + e.message); } };
      return (
        <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg flex flex-col max-h-[90vh]">
            <div className="bg-gray-50 p-4 border-b flex justify-between items-center rounded-t-xl"><h2 className="text-xl font-bold text-gray-800">データ管理</h2><button onClick={onClose} className="text-gray-400">✕</button></div>
            <div className="p-6 flex-1 overflow-y-auto"><textarea className="w-full h-64 p-3 text-xs font-mono border rounded-lg bg-gray-50" value={jsonString} onChange={(e) => setJsonString(e.target.value)} /><div className="flex gap-2 mt-2"><button onClick={handleCopy} className="text-xs bg-gray-100 px-2 py-1 rounded">コピー</button></div>{error && <div className="text-red-500 text-sm mt-2">{error}</div>}{successMsg && <div className="text-green-500 text-sm mt-2">{successMsg}</div>}</div>
            <div className="bg-gray-50 p-4 border-t flex justify-between"><button onClick={handleReset} className="text-red-600 text-sm">初期化</button><div className="flex gap-3"><button onClick={onClose} className="text-sm bg-white border px-3 py-2 rounded">閉じる</button><button onClick={handleImport} className="text-sm text-white bg-blue-600 px-3 py-2 rounded">読込</button></div></div>
          </div>
        </div>
      );
    };

    // --- Main App Component ---
    const App = () => {
      const [people, setPeople] = useState(() => {
        try {
          const savedData = localStorage.getItem(STORAGE_KEY);
          if (savedData) {
            const parsed = JSON.parse(savedData);
            return parsed.map(p => {
                if (!p.surname && p.name) {
                    const parts = p.name.split(/[\s　]+/);
                    return { ...p, surname: parts[0] || '', givenName: parts.slice(1).join(' ') || '', maidenName: p.maidenName || '' };
                }
                return p;
            });
          }
        } catch (e) { console.warn(e); }
        // Ensure initial data is laid out correctly on first load
        return performAutoLayout(INITIAL_PEOPLE);
      });

      const [viewport, setViewport] = useState({ x: 0, y: 0, scale: 1 });

      const handleFitView = useCallback(() => {
          if (people.length === 0) return;
          const minX = Math.min(...people.map(p => p.x));
          const maxX = Math.max(...people.map(p => p.x));
          const minY = Math.min(...people.map(p => p.y));
          const maxY = Math.max(...people.map(p => p.y));

          const contentWidth = maxX - minX + CARD_WIDTH + 100; // padding
          const contentHeight = maxY - minY + CARD_HEIGHT + 100;

          const scaleX = window.innerWidth / contentWidth;
          const scaleY = window.innerHeight / contentHeight;
          const newScale = Math.min(Math.min(scaleX, scaleY), 1); // max scale 1

          const centerX = (minX + maxX + CARD_WIDTH) / 2;
          const centerY = (minY + maxY + CARD_HEIGHT) / 2;

          setViewport({
              x: (window.innerWidth / 2) - (centerX * newScale),
              y: (window.innerHeight / 2) - (centerY * newScale),
              scale: newScale
          });
      }, [people]);

      // Initial Load Effect: Restore Viewport
      useEffect(() => {
          const hasSavedData = localStorage.getItem(STORAGE_KEY);
          if (!hasSavedData) {
              handleFitView();
          } else {
             const savedViewport = localStorage.getItem(VIEWPORT_KEY);
             if (savedViewport) {
                 try { setViewport(JSON.parse(savedViewport)); } catch(e){ handleFitView(); }
             } else {
                 handleFitView();
             }
          }
      }, []);

      const [viewSettings, setViewSettings] = useState({ showMaidenName: false, useGenderColor: false });
      const [visibleSurnames, setVisibleSurnames] = useState({});
      const [isFilterOpen, setIsFilterOpen] = useState(false);
      const getFilterName = useCallback((p) => (viewSettings.showMaidenName && p.maidenName ? p.maidenName : p.surname || '名称未設定'), [viewSettings.showMaidenName]);

      // Update visibleSurnames when data or settings change
      useEffect(() => {
          const names = new Set(); people.forEach(p => names.add(getFilterName(p)));
          setVisibleSurnames(prev => {
              const next = {}; 
              Array.from(names).forEach(s => {
                  next[s] = prev[s] !== undefined ? prev[s] : true;
              });
              return next;
          });
      }, [people, getFilterName, viewSettings.showMaidenName]); // Added explicit dependency

      useEffect(() => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(people));
      }, [people]);

      useEffect(() => {
          const timer = setTimeout(() => {
              localStorage.setItem(VIEWPORT_KEY, JSON.stringify(viewport));
          }, 500);
          return () => clearTimeout(timer);
      }, [viewport]);

      const [selectedPersonId, setSelectedPersonId] = useState(null);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [isSettingsOpen, setIsSettingsOpen] = useState(false);
      const [draggingNodeId, setDraggingNodeId] = useState(null);
      const [isPanning, setIsPanning] = useState(false);
      
      const mousePosRef = useRef({ x: 0, y: 0 });
      const dragStartPosRef = useRef({ x: 0, y: 0 });
      const isDraggingRef = useRef(false);
      const rafIdRef = useRef(null);
      const containerRef = useRef(null);
      const filterRef = useRef(null);

      useEffect(() => {
          const handleClickOutside = (e) => { if (filterRef.current && !filterRef.current.contains(e.target) && isFilterOpen) setIsFilterOpen(false); };
          document.addEventListener('mousedown', handleClickOutside);
          return () => document.removeEventListener('mousedown', handleClickOutside);
      }, [isFilterOpen]);

      const checkVisibility = useCallback((p) => visibleSurnames[getFilterName(p)] !== false, [visibleSurnames, getFilterName]);
      const relationshipMap = useMemo(() => selectedPersonId ? analyzeRelationships(selectedPersonId, people) : new Map(), [selectedPersonId, people]);

      const connections = useMemo(() => {
        const lines = [];
        const personMap = new Map(people.map(p => [p.id, p]));
        people.forEach(person => {
          person.spouses.forEach(spouseId => {
            const spouse = personMap.get(spouseId);
            if (spouse && person.id < spouse.id && checkVisibility(person) && checkVisibility(spouse)) {
              const start = getCardCenter(person.x, person.y), end = getCardCenter(spouse.x, spouse.y);
              lines.push(<path key={`spouse-${person.id}-${spouse.id}`} d={`M ${start.x} ${start.y} L ${end.x} ${end.y}`} stroke="#333" strokeWidth="2" fill="none" strokeDasharray="5,5" />);
              lines.push(<circle key={`j-${person.id}-${spouse.id}`} cx={(start.x+end.x)/2} cy={(start.y+end.y)/2} r={4} fill="#fff" stroke="#333" strokeWidth="2" />);
            }
          });
        });
        const familyMap = new Map();
        people.forEach(child => {
            if (!checkVisibility(child) || child.parents.length === 0) return;
            const key = [...child.parents].sort().join('|');
            if (!familyMap.has(key)) familyMap.set(key, { parents: child.parents, children: [] });
            familyMap.get(key).children.push(child);
        });
        familyMap.forEach((family, key) => {
            const parents = family.parents.map(pid => personMap.get(pid)).filter(p => !!p && checkVisibility(p));
            if (parents.length === 0 || family.children.length === 0) return;
            let startX, startY;
            if (parents.length >= 2) {
                 const c1 = getCardCenter(parents[0].x, parents[0].y), c2 = getCardCenter(parents[1].x, parents[1].y);
                 startX = (c1.x + c2.x) / 2; startY = c1.y; 
            } else { const bottom = getCardBottom(parents[0].x, parents[0].y); startX = bottom.x; startY = bottom.y; }
            let childMinX = Infinity, childMaxX = -Infinity, childTopY = Infinity;
            family.children.forEach(c => {
                 const top = getCardTop(c.x, c.y);
                 childMinX = Math.min(childMinX, top.x); childMaxX = Math.max(childMaxX, top.x); childTopY = Math.min(childTopY, top.y);
            });
            const childLineY = childTopY - 40; 
            lines.push(<path key={`d-${key}`} d={`M ${startX} ${startY} L ${startX} ${childLineY}`} stroke="#333" strokeWidth="2" fill="none" />);
            lines.push(<path key={`cb-${key}`} d={`M ${Math.min(childMinX, startX)} ${childLineY} L ${Math.max(childMaxX, startX)} ${childLineY}`} stroke="#333" strokeWidth="2" fill="none" />);
            family.children.forEach(c => { const top = getCardTop(c.x, c.y); lines.push(<path key={`cs-${c.id}`} d={`M ${top.x} ${childLineY} L ${top.x} ${top.y}`} stroke="#333" strokeWidth="2" fill="none" />); });
        });
        return lines;
      }, [people, checkVisibility]);

      useEffect(() => {
        let lastX = mousePosRef.current.x, lastY = mousePosRef.current.y;
        const loop = () => {
          const cx = mousePosRef.current.x, cy = mousePosRef.current.y;
          const dx = cx - lastX, dy = cy - lastY;
          if (dx !== 0 || dy !== 0) {
            if (draggingNodeId) setPeople(prev => prev.map(p => p.id === draggingNodeId ? { ...p, x: p.x + (dx/viewport.scale), y: p.y + (dy/viewport.scale) } : p));
            else if (isPanning) setViewport(prev => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
            lastX = cx; lastY = cy;
          }
          rafIdRef.current = requestAnimationFrame(loop);
        };
        if (draggingNodeId || isPanning) { lastX = mousePosRef.current.x; lastY = mousePosRef.current.y; loop(); }
        return () => { if (rafIdRef.current) cancelAnimationFrame(rafIdRef.current); };
      }, [draggingNodeId, isPanning, viewport.scale]);

      const handleCanvasWheel = useCallback((e) => {
        if (e.ctrlKey || e.metaKey) { e.preventDefault(); setViewport(prev => ({ ...prev, scale: Math.min(Math.max(0.1, prev.scale - e.deltaY * 0.001), 4) })); }
        else setViewport(prev => ({ ...prev, x: prev.x - e.deltaX, y: prev.y - e.deltaY }));
      }, []);

      const handleAutoLayout = () => {
        const visiblePeople = people.filter(checkVisibility);
        const layouted = performAutoLayout(visiblePeople);
        const layoutMap = new Map(layouted.map(p => [p.id, {x: p.x, y: p.y}]));
        setPeople(prev => prev.map(p => layoutMap.has(p.id) ? { ...p, ...layoutMap.get(p.id) } : p));
        
        // Fit view after layout
        setTimeout(() => {
             if (layouted.length === 0) return;
             const minX = Math.min(...layouted.map(p => p.x));
             const maxX = Math.max(...layouted.map(p => p.x));
             const minY = Math.min(...layouted.map(p => p.y));
             const maxY = Math.max(...layouted.map(p => p.y));

             const contentWidth = maxX - minX + CARD_WIDTH + 100;
             const contentHeight = maxY - minY + CARD_HEIGHT + 100;
             const scaleX = window.innerWidth / contentWidth;
             const scaleY = window.innerHeight / contentHeight;
             const newScale = Math.min(Math.min(scaleX, scaleY), 1);
             const centerX = (minX + maxX + CARD_WIDTH) / 2;
             const centerY = (minY + maxY + CARD_HEIGHT) / 2;

             setViewport({
                  x: (window.innerWidth / 2) - (centerX * newScale),
                  y: (window.innerHeight / 2) - (centerY * newScale),
                  scale: newScale
             });
        }, 10);
      };

      const handleAddRelative = (sourceId, type, data) => {
          const source = people.find(p => p.id === sourceId);
          if (!source) return;
          const newId = generateId();
          const newPerson = { id: newId, surname: data.surname, givenName: data.givenName, maidenName: '', birthDate: data.birthDate, gender: data.gender, parents: [], spouses: [], children: [], x: source.x, y: source.y };
          
          if (type === 'spouse') {
              newPerson.x += CARD_WIDTH + 50;
              newPerson.spouses = [sourceId];
              const childrenIds = source.children;
              setPeople(prev => {
                  let next = prev.map(p => p.id === sourceId ? { ...p, spouses: [...p.spouses, newId] } : p);
                  if (childrenIds.length > 0) {
                      newPerson.children = [...childrenIds];
                      next = next.map(p => childrenIds.includes(p.id) && !p.parents.includes(newId) ? { ...p, parents: [...p.parents, newId] } : p);
                  }
                  return [...next, newPerson];
              });
          } else if (type === 'child') {
              const spouseId = source.spouses[0];
              const spouse = spouseId ? people.find(p => p.id === spouseId) : null;
              newPerson.parents = spouse ? [sourceId, spouseId] : [sourceId];
              newPerson.y += CARD_HEIGHT + 100;
              setPeople(prev => [...prev.map(p => (p.id === sourceId || (spouse && p.id === spouseId)) ? { ...p, children: [...p.children, newId] } : p), newPerson]);
          } else if (type === 'parent') {
              const existingPid = source.parents[0];
              if (existingPid) {
                  newPerson.children = [sourceId]; newPerson.spouses = [existingPid]; newPerson.x += CARD_WIDTH + 50; newPerson.y -= CARD_HEIGHT + 100;
                  setPeople(prev => [...prev.map(p => p.id === sourceId ? { ...p, parents: [...p.parents, newId] } : p.id === existingPid ? { ...p, spouses: [...p.spouses, newId] } : p), newPerson]);
              } else {
                  newPerson.children = [sourceId]; newPerson.y -= CARD_HEIGHT + 100;
                  setPeople(prev => [...prev.map(p => p.id === sourceId ? { ...p, parents: [...p.parents, newId] } : p), newPerson]);
              }
          }
          setTimeout(() => { setSelectedPersonId(newId); setIsModalOpen(true); }, 100);
      };

      const handleToggleMaidenName = () => {
          if (selectedPersonId) {
              setPeople(prev => prev.map(p => 
                  p.id === selectedPersonId 
                  ? { ...p, displayMaidenName: !p.displayMaidenName } 
                  : p
              ));
          } else {
              const nextState = !viewSettings.showMaidenName;
              setViewSettings(prev => ({ ...prev, showMaidenName: nextState }));
              setPeople(prev => prev.map(p => ({ ...p, displayMaidenName: nextState })));
          }
      };
      
      const handleZoomIn = () => {
        if (selectedPersonId) {
            const p = people.find(x => x.id === selectedPersonId);
            if(p) {
                 const cx = p.x + CARD_WIDTH/2;
                 const cy = p.y + CARD_HEIGHT/2;
                 const newScale = Math.min(viewport.scale * 1.2, 4);
                 setViewport({
                     scale: newScale,
                     x: window.innerWidth/2 - cx * newScale,
                     y: window.innerHeight/2 - cy * newScale
                 });
                 return;
            }
        }
        setViewport(prev => ({ ...prev, scale: Math.min(prev.scale * 1.2, 4) }));
      };
      const handleZoomOut = () => setViewport(prev => ({ ...prev, scale: Math.max(prev.scale / 1.2, 0.1) }));

      const selectedPerson = people.find(p => p.id === selectedPersonId) || null;

      return (
        <div className="w-screen h-screen bg-canvas overflow-hidden flex flex-col font-sans text-slate-800">
           <div className="absolute top-4 left-4 z-50 flex flex-col gap-2 pointer-events-none">
            <div className="bg-white/90 backdrop-blur rounded-lg shadow-lg border border-gray-200 p-1 flex gap-1 items-center pointer-events-auto">
                <div className="flex items-center border-r border-gray-200 pr-1 mr-1 gap-1">
                    <button onClick={handleZoomIn} className="p-1.5 hover:bg-gray-100 rounded text-gray-600" title="拡大"><svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg></button>
                    <button onClick={handleZoomOut} className="p-1.5 hover:bg-gray-100 rounded text-gray-600" title="縮小"><svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20 12H4" /></svg></button>
                    <button onClick={handleFitView} className="p-1.5 hover:bg-gray-100 rounded text-gray-600 font-bold text-xs px-2" title="全体表示">Fit</button>
                </div>
                <button onClick={handleAutoLayout} className="px-3 py-1.5 text-xs font-bold text-gray-700 hover:bg-gray-100 rounded flex items-center gap-1 transition">自動配置</button>
                <div className="w-px h-4 bg-gray-200 mx-1"></div>
                <button onClick={handleToggleMaidenName} className={`px-3 py-1.5 text-xs font-bold rounded flex items-center gap-1 transition ${viewSettings.showMaidenName ? 'bg-indigo-100 text-indigo-700' : 'text-gray-700 hover:bg-gray-100'}`}>旧姓表示</button>
                <button onClick={() => setViewSettings(s => ({...s, useGenderColor: !s.useGenderColor}))} className={`px-3 py-1.5 text-xs font-bold rounded flex items-center gap-1 transition ${viewSettings.useGenderColor ? 'bg-blue-100 text-blue-700' : 'text-gray-700 hover:bg-gray-100'}`}>性別色分</button>
                <div className="w-px h-4 bg-gray-200 mx-1"></div>
                <div className="relative" ref={filterRef}>
                    <button onClick={() => setIsFilterOpen(!isFilterOpen)} className="px-3 py-1.5 text-xs font-bold rounded flex items-center gap-1 transition text-gray-700 hover:bg-gray-100">絞り込み</button>
                    {isFilterOpen && (
                        <div className="absolute top-full left-0 mt-2 w-48 bg-white rounded-lg shadow-xl border overflow-hidden z-50 animate-in fade-in zoom-in-95 duration-100">
                             <div className="max-h-60 overflow-y-auto p-1">
                                {Object.keys(visibleSurnames).sort().map(s => <label key={s} className="flex items-center gap-2 px-2 py-1.5 hover:bg-gray-50 rounded cursor-pointer"><input type="checkbox" checked={visibleSurnames[s]!==false} onChange={(e) => setVisibleSurnames(prev => ({...prev, [s]: e.target.checked}))} className="rounded text-blue-600 h-4 w-4" /><span className="text-sm truncate">{s}</span></label>)}
                             </div>
                             <div className="border-t p-1 flex justify-between bg-gray-50"><button onClick={() => setVisibleSurnames(p => { const n={}; Object.keys(p).forEach(k=>n[k]=true); return n; })} className="text-xs text-blue-600 px-2">全選択</button><button onClick={() => setVisibleSurnames(p => { const n={}; Object.keys(p).forEach(k=>n[k]=false); return n; })} className="text-xs text-gray-500 px-2">全解除</button></div>
                        </div>
                    )}
                </div>
            </div>
          </div>
          <div className="absolute top-4 right-4 z-50 pointer-events-none"><button onClick={() => setIsSettingsOpen(true)} className="pointer-events-auto p-2 bg-white/90 backdrop-blur border rounded-full hover:bg-gray-100 shadow-lg"><svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg></button></div>

          <div ref={containerRef} className={`flex-1 w-full h-full relative cursor-${isPanning || draggingNodeId ? 'grabbing' : 'default'}`} onWheel={handleCanvasWheel} onMouseDown={(e) => { if(e.button===1||(e.button===0&&e.altKey)) { setIsPanning(true); mousePosRef.current = {x:e.clientX, y:e.clientY}; e.preventDefault(); } }} onMouseMove={(e) => { mousePosRef.current={x:e.clientX, y:e.clientY}; if(!isDraggingRef.current&&(draggingNodeId||isPanning)) { if(Math.abs(e.clientX-dragStartPosRef.current.x)+Math.abs(e.clientY-dragStartPosRef.current.y)>5) isDraggingRef.current=true; } }} onMouseUp={() => { setIsPanning(false); setDraggingNodeId(null); }} onMouseLeave={() => { setIsPanning(false); setDraggingNodeId(null); }}>
            <div style={{ transform: `translate(${viewport.x}px, ${viewport.y}px) scale(${viewport.scale})`, transformOrigin: '0 0', width: '100%', height: '100%', position: 'absolute' }}>
              <svg className="absolute top-0 left-0 w-full h-full overflow-visible pointer-events-none" style={{ zIndex: 0 }}>{connections}</svg>
              {people.map(p => <NodeCard key={p.id} person={p} isSelected={selectedPersonId === p.id} isHidden={!checkVisibility(p)} relationship={relationshipMap.get(p.id)} viewSettings={viewSettings} onMouseDown={(e, id) => { setDraggingNodeId(id); mousePosRef.current={x:e.clientX, y:e.clientY}; dragStartPosRef.current={x:e.clientX, y:e.clientY}; isDraggingRef.current=false; }} onClick={(id) => { if(!isDraggingRef.current) setSelectedPersonId(prev => prev===id?null:id); }} onEdit={(id) => { setSelectedPersonId(id); setIsModalOpen(true); }} />)}
            </div>
          </div>
          <EditModal isOpen={isModalOpen} person={selectedPerson} onClose={() => setIsModalOpen(false)} onSave={(id, u) => setPeople(prev => prev.map(p => p.id===id?{...p,...u}:p))} onDelete={(id) => { setIsModalOpen(false); setSelectedPersonId(null); setPeople(prev => prev.filter(p => p.id!==id).map(p => ({...p, parents:p.parents.filter(x=>x!==id), spouses:p.spouses.filter(x=>x!==id), children:p.children.filter(x=>x!==id)}))); }} onAddRelative={handleAddRelative} />
          <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} currentData={people} onImport={(d) => { setPeople(d); setSelectedPersonId(null); setViewport({x:0,y:0,scale:1}); }} onReset={() => { setPeople(INITIAL_PEOPLE); setViewport({x:0,y:0,scale:1}); }} />
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
